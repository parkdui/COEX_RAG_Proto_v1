<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover"
    />
    <title>COEX RAG Assistant</title>
    <link rel="stylesheet" href="./styles.css" />
  </head>
  <body>
    <header class="topbar">
      <div class="title">COEX 이벤트 안내</div>
      <div id="status" class="status">연결 확인 중…</div>
    </header>

    <div class="main-layout">
      <section class="prompt-editor">
        <aside class="sidebar">
          <h3>System Prompt</h3>
          <textarea
            id="system-prompt"
            rows="6"
            style="width: 100%"
            placeholder="System Prompt를 입력하세요"
          ></textarea>
        </aside>
      </section>

      <div id="token-info" class="token-info"></div>

      <main class="chat-area">
        <div id="chat" class="chat"></div>
        <form id="composer" class="composer" autocomplete="off">
          <input
            id="q"
            class="input"
            type="text"
            inputmode="search"
            placeholder="예) 이번 주말 가족 체험 프로그램 추천해줘"
          />
          <button class="send" aria-label="보내기">보내기</button>
        </form>
      </main>

      <template id="bubble">
        <div class="bubble">
          <div class="bubble-inner"></div>
        </div>
      </template>
    </div>

    <!-- <script src="/socket.io/socket.io.js"></script> -->
    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <script>
      // 기본 백엔드 URL (Render/Railway 같은 고정 주소가 있으면 여기 넣기)
      const DEFAULT_API = "https://10bbb4da001e.ngrok-free.app"; // 임시: ngrok 주소 or 고정 백엔드 주소

      // 편의기능: ?api= 로 오버라이드 가능 + localStorage 저장
      const urlApi = new URLSearchParams(location.search).get("api");
      const lsApi = localStorage.getItem("API_BASE");
      const API = urlApi || lsApi || DEFAULT_API;
      if (urlApi) localStorage.setItem("API_BASE", urlApi);

      console.log("[client] API =", API);

      // WebSocket 연결
      const socket = io(API, {
        path: "/socket.io",
        transports: ["websocket"],
      });

      socket.on("connect", () => {
        const statusEl = document.getElementById("status");
        statusEl.textContent = "연결됨";
        statusEl.classList.remove("bad");
        statusEl.classList.add("ok");
        console.log("[socket] connected:", socket.id);
      });
      socket.on("disconnect", () => {
        const statusEl = document.getElementById("status");
        statusEl.textContent = "연결 끊김";
        statusEl.classList.remove("ok");
        statusEl.classList.add("bad");
        console.log("[socket] disconnected");
      });

      // (선택) 헬스체크 로그로 백엔드 통신 확인
      fetch(`${API}/health`)
        .then((r) => r.json())
        .then((j) => console.log("[health]", j))
        .catch((err) => console.warn("[health error]", err));
      // 만약 fetch를 쓰는 부분이 있다면 이렇게:
      // fetch(`${API}/health`)
      // fetch(`${API}/query_with_embedding`, { ... })
    </script>

    <script>
      function addTokenLine(afterNode, tokens) {
        const div = document.createElement("div");
        div.className = "token-line";
        const { input = 0, output = 0, total = input + output } = tokens || {};
        div.textContent = `📊 토큰 사용량: 입력 ${input.toLocaleString()} / 출력 ${output.toLocaleString()} / 총 ${total.toLocaleString()}`;
        // 말풍선 바로 뒤에 꽂기
        afterNode.insertAdjacentElement("afterend", div);
        div.scrollIntoView({ behavior: "smooth", block: "end" });
      }

      function addBotTurn(answerText, tokens, hits) {
        // ① 턴 래퍼
        const turn = document.createElement("div");
        turn.className = "turn";
        chat.appendChild(turn);

        // ② 봇 말풍선
        const node = bubbleTpl.content.firstElementChild.cloneNode(true);
        node.classList.add("bot");
        node.querySelector(".bubble-inner").textContent =
          answerText || "(응답 없음)";
        turn.appendChild(node);

        // ③ 토큰 라인(있으면)
        if (tokens) {
          const div = document.createElement("div");
          div.className = "token-line";
          const { input = 0, output = 0, total } = tokens || {};
          const totalSafe = Number.isFinite(total) ? total : input + output;
          div.textContent =
            `📊 토큰 사용량: 입력 ${input.toLocaleString()} / ` +
            `출력 ${output.toLocaleString()} / 총 ${totalSafe.toLocaleString()}`;
          turn.appendChild(div);
        }

        // ④ 히츠(있으면) - 같은 턴 안에 붙여주면 흐름이 자연스러움
        if (hits && hits.length) {
          const lines = hits.map(
            (h, i) =>
              `[${i + 1}] ${h?.meta?.title || ""} | ${h?.meta?.date || ""} | ${
                h?.meta?.venue || ""
              }`
          );
          const details = document.createElement("details");
          details.className = "hits";
          const sum = document.createElement("summary");
          sum.textContent = `참조한 이벤트 (${hits.length})`;
          const pre = document.createElement("pre");
          pre.textContent = lines.join("\n");
          details.appendChild(sum);
          details.appendChild(pre);
          turn.appendChild(details);
        }

        turn.scrollIntoView({ behavior: "smooth", block: "end" });
        return turn;
      }

      // ---- DOM refs ----
      const promptBox = document.getElementById("system-prompt");
      const chat = document.getElementById("chat");
      const form = document.getElementById("composer");
      const q = document.getElementById("q");
      const statusEl = document.getElementById("status");
      const bubbleTpl = document.getElementById("bubble");

      // ---- socket.io ----
      //   const socket = io();

      // pending 응답(생각 중…) 버블 참조
      let pendingBubble = null;

      // ---- UI helpers (기존 유지) ----
      function addBubble(text, who = "bot", html = false) {
        const node = bubbleTpl.content.firstElementChild.cloneNode(true);
        node.classList.add(who);
        const inner = node.querySelector(".bubble-inner");
        if (html) inner.innerHTML = text;
        else inner.textContent = text;
        chat.appendChild(node);
        node.scrollIntoView({ behavior: "smooth", block: "end" });
        return node;
      }

      // [추가] 시간/요일에 따라 동적인 인사말을 생성하는 함수
      function getDynamicGreeting() {
        const now = new Date();
        const hour = now.getHours(); // 0-23시
        const day = now.getDay(); // 0:일요일, 1:월요일, ..., 6:토요일

        // 인사말 후보 목록
        let possibleGreetings = [];

        // 1. 시간에 따른 기본 인사말 추가
        if (hour >= 5 && hour < 12) {
          // 오전
          possibleGreetings.push(
            "좋은 아침입니다! 오늘 코엑스에서 어떤 즐거운 일을 계획하고 계신가요?",
            "활기찬 아침이네요! 무엇을 도와드릴까요?",
            "좋은 아침이에요! 저는 이솔이라고 해요. 오늘 코엑스엔 무슨 일로 오셨나요?"
          );
        } else if (hour >= 12 && hour < 18) {
          // 오후
          possibleGreetings.push(
            "편안한 오후입니다. 코엑스에서의 즐거운 시간을 위해 무엇이 궁금하세요?",
            "점심은 맛있게 드셨나요? 궁금한 점이 있다면 편하게 물어보세요!",
            "좋은 오후예요! 코엑스 이벤트 안내 AI, 이솔입니다. 무엇을 도와드릴까요?"
          );
        } else {
          // 저녁 및 밤
          possibleGreetings.push(
            "어느덧 저녁이네요. 저 이솔과 함께, 오늘 하루의 마무리를 코엑스에서 즐겨보는 건 어때요?",
            "저녁 시간도 코엑스와 함께! 어떤 행사를 찾고 계신가요?",
            "안녕하세요! 코엑스 이벤트 안내 AI, 이솔입니다. 무엇을 도와드릴까요?"
          );
        }

        // 2. 요일에 따른 특별 인사말 추가
        if (day === 5) {
          // 금요일
          possibleGreetings.push(
            "신나는 금요일이네요! 주말에 즐길 만한 행사를 찾아보세요."
          );
        } else if (day === 0 || day === 6) {
          // 주말 (일요일 또는 토요일)
          possibleGreetings.push(
            "즐거운 주말입니다! 코엑스에서 특별한 추억을 만들어보세요."
          );
        }

        // 3. 후보 목록에서 랜덤으로 하나를 선택하여 반환
        const randomIndex = Math.floor(
          Math.random() * possibleGreetings.length
        );
        return possibleGreetings[randomIndex];
      }

      // ---- socket events ----
      socket.on("connect", () => {
        statusEl.textContent = "연결됨";
        statusEl.classList.remove("bad");
        statusEl.classList.add("ok");
        console.log("[socket] connected:", socket.id);
      });

      socket.on("disconnect", () => {
        statusEl.textContent = "연결 끊김";
        statusEl.classList.remove("ok");
        statusEl.classList.add("bad");
        console.log("[socket] disconnected");
      });

      // 서버에서 `reply` 이벤트로 내려줌
      // - 문자열: 바로 봇 말풍선
      // - 객체: { answer, hits } 또는 { error }
      socket.on("reply", (payload) => {
        if (pendingBubble) {
          pendingBubble.remove();
          pendingBubble = null;
        }

        if (typeof payload === "string") {
          addBubble(payload, "bot");
          return;
        }
        if (payload?.error) {
          addBubble("⚠️ " + payload.error, "bot");
          return;
        }

        // 1) 말풍선 DOM을 변수로 받기
        // const botNode = addBubble(payload?.answer || "(응답 없음)", "bot");

        // // 2) 그 말풍선 "바로 아래"에 토큰 라인 삽입
        // if (payload?.tokens) {
        //   addTokenLine(botNode, payload.tokens);
        // }

        addBotTurn(payload?.answer, payload?.tokens, payload?.hits);

        // addBubble(payload?.answer || "(응답 없음)", "bot");
        // if (payload?.hits) addHits(payload.hits);

        // // ✅ 토큰 정보 표시
        // if (payload?.tokens) {
        //   const { input, output, total } = payload.tokens;
        //   const tokenInfoEl = document.getElementById("token-info");
        //   tokenInfoEl.textContent = `📊 토큰 사용량: 입력 ${input}, 출력 ${output}, 총 ${total}`;
        // }
      });

      // ---- form submit → socket.emit ----
      form.addEventListener("submit", (e) => {
        e.preventDefault();
        const text = q.value.trim();
        if (!text) return;

        // 나(사용자) 말풍선
        addBubble(text, "you");
        q.value = "";

        // 생각 중…
        pendingBubble = addBubble("생각 중…", "bot");
        pendingBubble.classList.add("thinking");

        // 서버로 질문 전송 (systemPrompt 포함)
        socket.emit("message", {
          question: text,
          systemPrompt: promptBox.value,
        });
      });

      // 모바일/엔터 전송
      q.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && !e.shiftKey) {
          e.preventDefault();
          form.requestSubmit();
        }
      });

      // [수정] 시작 안내 메시지를 동적으로 생성된 인사말로 교체
      addBubble(getDynamicGreeting(), "bot");
      q.focus();
    </script>
  </body>
</html>
